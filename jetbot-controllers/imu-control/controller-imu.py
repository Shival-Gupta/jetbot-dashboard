#!/usr/bin/env python3
"""
controller-imu.py
Version: 2.0

Description: Enhanced controller interface for a Mecanum wheel robot with IMU-based
drift correction. Provides an intuitive interface to control the robot with various
movement patterns and real-time status display.

Compatible with:
  - mecanum-imu-controller.ino
  - mecanum-advanced-controller.ino

Original description follows:
"""

"""
Enhanced Mecanum Robot Controller Interface

This script provides a user-friendly interface to control a mecanum wheel robot
with drift correction capability. It sends commands to an Arduino running the
corresponding firmware via serial communication.

Features:
- Intuitive keyboard control interface
- Preset movement patterns for common maneuvers
- Continuous (hold) movement mode
- Real-time status display
- Configurable movement parameters

Usage:
  python mecanum_controller.py [-p PORT] [-s SPEED] [-d DURATION]

Author: Generated by Claude AI
Version: 2.0
"""

import argparse
import serial
import sys
import time
import threading
import signal

# =================== Configuration =================== #
DEFAULT_SERIAL_PORT = "/dev/ttyACM0"  # Change as needed (e.g., "COM3" on Windows)
DEFAULT_BAUD_RATE = 9600
DEFAULT_MOVE_DURATION = 2.0       # Default duration for momentary movements (seconds)
DEFAULT_MOTOR_SPEED = 150         # Default speed value (0-255)
SERIAL_TIMEOUT = 1.0              # Serial read timeout
CONNECTION_RETRIES = 3            # Number of connection attempts

# =================== Command Definitions =================== #
# Each command defines the speeds for [Front Left, Front Right, Rear Left, Rear Right]
# Positive values move forward/right, negative values move backward/left
class Commands:
    def __init__(self, speed=DEFAULT_MOTOR_SPEED):
        self.speed = speed
        self.update_commands()
        
    def update_commands(self):
        """Update all commands based on current speed setting"""
        self.COMMANDS = {
            # Basic movements (with drift correction for forward/backward)
            'w': [self.speed, self.speed, self.speed, self.speed],           # Forward
            's': [-self.speed, -self.speed, -self.speed, -self.speed],        # Backward
            'a': [-self.speed, self.speed, self.speed, -self.speed],          # Strafe Left
            'd': [self.speed, -self.speed, -self.speed, self.speed],          # Strafe Right,
            
            # Rotational movements
            'q': [self.speed, -self.speed, self.speed, -self.speed],          # Rotate Left (CCW)
            'e': [-self.speed, self.speed, -self.speed, self.speed],          # Rotate Right (CW)
            
            # Diagonal movements
            'z': [0, self.speed, self.speed, 0],                              # Diagonal Forward Left
            'x': [self.speed, 0, 0, self.speed],                              # Diagonal Forward Right
            'c': [0, -self.speed, -self.speed, 0],                            # Diagonal Backward Left
            'v': [-self.speed, 0, 0, -self.speed],                            # Diagonal Backward Right
            
            # Curved movements
            'r': [int(self.speed * 1.5), int(self.speed * 0.5),
                  int(self.speed * 1.5), int(self.speed * 0.5)],              # Curved Forward Left
            't': [int(self.speed * 0.5), int(self.speed * 1.5),
                  int(self.speed * 0.5), int(self.speed * 1.5)],              # Curved Forward Right
            'f': [-int(self.speed * 0.5), -int(self.speed * 1.5),
                  -int(self.speed * 0.5), -int(self.speed * 1.5)],            # Curved Backward Left
            'g': [-int(self.speed * 1.5), -int(self.speed * 0.5),
                  -int(self.speed * 1.5), -int(self.speed * 0.5)]             # Curved Backward Right
        }
        # Add stop command
        self.COMMANDS['stop'] = [0, 0, 0, 0]

    def get_speed(self):
        """Get current speed setting"""
        return self.speed
        
    def set_speed(self, new_speed):
        """Update speed setting and recalculate all commands"""
        self.speed = max(0, min(255, new_speed))
        self.update_commands()
        return self.speed
        
    def increase_speed(self, increment=10):
        """Increase speed by the specified increment"""
        return self.set_speed(self.speed + increment)
        
    def decrease_speed(self, decrement=10):
        """Decrease speed by the specified decrement"""
        return self.set_speed(self.speed - decrement)

# =================== Helper Classes =================== #
class RobotController:
    """Manages communication with the robot and executes movement commands"""
    
    def __init__(self, port=DEFAULT_SERIAL_PORT, baud_rate=DEFAULT_BAUD_RATE, 
                 move_duration=DEFAULT_MOVE_DURATION, speed=DEFAULT_MOTOR_SPEED):
        self.port = port
        self.baud_rate = baud_rate
        self.move_duration = move_duration
        self.serial_connection = None
        self.commands = Commands(speed)
        self.is_connected = False
        self.hold_active = False
        self.lock = threading.Lock()
        
    def connect(self):
        """Establish serial connection to the robot"""
        for attempt in range(CONNECTION_RETRIES):
            try:
                if self.serial_connection:
                    self.serial_connection.close()
                
                self.serial_connection = serial.Serial(
                    self.port, 
                    self.baud_rate,
                    timeout=SERIAL_TIMEOUT
                )
                
                # Wait for Arduino to reset
                time.sleep(2)
                
                # Flush any pending data
                self.serial_connection.reset_input_buffer()
                self.serial_connection.reset_output_buffer()
                
                self.is_connected = True
                print(f"Connected to robot on {self.port}")
                return True
                
            except serial.SerialException as e:
                print(f"Connection attempt {attempt+1}/{CONNECTION_RETRIES} failed: {str(e)}")
                time.sleep(1)
        
        print(f"Failed to connect to robot on {self.port}")
        return False
        
    def disconnect(self):
        """Close the serial connection"""
        if self.serial_connection:
            # Stop motors before disconnecting
            self.stop()
            time.sleep(0.1)  # Brief delay to ensure command is sent
            
            self.serial_connection.close()
            self.is_connected = False
            print("Disconnected from robot")
            
    def send_command(self, speeds):
        """Send a motor speed command to the robot"""
        if not self.is_connected:
            print("Error: Not connected to robot")
            return False
            
        try:
            with self.lock:
                command = ",".join(map(str, speeds)) + "\n"
                self.serial_connection.write(command.encode('utf-8'))
                self.serial_connection.flush()
                
                # Read any response from the Arduino (non-blocking)
                self._read_response()
                return True
                
        except Exception as e:
            print(f"Error sending command: {str(e)}")
            self.is_connected = False
            return False
            
    def _read_response(self):
        """Read and display any response from the Arduino"""
        try:
            response = self.serial_connection.readline().decode('utf-8').strip()
            if response:
                print(f"Robot: {response}")
        except Exception:
            pass
            
    def move(self, direction):
        """Execute a movement in the specified direction"""
        if direction not in self.commands.COMMANDS:
            print(f"Unknown direction: {direction}")
            return False
            
        motor_speeds = self.commands.COMMANDS[direction]
        return self.send_command(motor_speeds)
        
    def move_for_duration(self, direction):
        """Move in the specified direction for the configured duration"""
        if not self.move(direction):
            return False
            
        time.sleep(self.move_duration)
        return self.stop()
        
    def start_hold(self, direction):
        """Start continuous movement in the specified direction"""
        if self.hold_active:
            self.stop()
            
        if not self.move(direction):
            return False
            
        self.hold_active = True
        print(f"Holding movement: {direction}")
        return True
        
    def stop(self):
        """Stop all motors"""
        self.hold_active = False
        return self.send_command(self.commands.COMMANDS['stop'])
        
    def set_speed(self, speed):
        """Set the motor speed"""
        old_speed = self.commands.get_speed()
        new_speed = self.commands.set_speed(speed)
        print(f"Speed changed: {old_speed} -> {new_speed}")
        return True
        
    def increase_speed(self):
        """Increase the motor speed"""
        old_speed = self.commands.get_speed()
        new_speed = self.commands.increase_speed()
        print(f"Speed increased: {old_speed} -> {new_speed}")
        return True
        
    def decrease_speed(self):
        """Decrease the motor speed"""
        old_speed = self.commands.get_speed()
        new_speed = self.commands.decrease_speed()
        print(f"Speed decreased: {old_speed} -> {new_speed}")
        return True
        
    def set_move_duration(self, duration):
        """Set the movement duration for momentary commands"""
        self.move_duration = max(0.1, duration)
        print(f"Move duration set to {self.move_duration} seconds")
        return True 